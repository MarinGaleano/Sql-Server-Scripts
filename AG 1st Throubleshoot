

--Check Database HADR healthy status -- on primary

SELECT  
    ag.name AS [AGName],
    ar.replica_server_name AS [ReplicaServer],
    dbs.database_name,
    drs.synchronization_state_desc,
    drs.synchronization_health_desc,
    drs.is_suspended,
    drs.suspend_reason_desc
FROM sys.dm_hadr_database_replica_states AS drs
JOIN sys.availability_databases_cluster AS dbs
    ON drs.group_database_id = dbs.group_database_id
JOIN sys.availability_replicas AS ar
    ON drs.replica_id = ar.replica_id
JOIN sys.availability_groups AS ag
    ON ar.group_id = ag.group_id
ORDER BY ag.name, dbs.database_name;


--Check for HADR errors -- all servers
EXEC xp_readerrorlog 0, 1, N'Always On';

-- Check for database specific errors -- all servers
EXEC xp_readerrorlog 0, 1, N'Database

-- Check changing roles on HADR run on all servers till find who was the primary
EXEC xp_readerrorlog 0, 1, N'is changing roles', N'primary';


-- Check rollback on secondary 
SELECT  session_id, percent_complete, estimated_completion_time, command, status
FROM sys.dm_exec_requests
WHERE command LIKE '%DB STARTUP%';

SELECT
    database_id,
    DB_NAME(database_id) AS DatabaseName,
    percent_complete,
    estimated_completion_time / 1000 / 60 AS EstimatedMinutesLeft,
    command,
    start_time,
    total_elapsed_time / 1000 / 60 AS ElapsedMinutes
FROM sys.dm_exec_requests
WHERE command IN ('DB STARTUP', 'RESTORE DATABASE', 'ROLLFORWARD', 'ROLLBACK');


-- Before Fail over
-- Check all databases for open tran
SET NOCOUNT ON;

IF OBJECT_ID('tempdb..#OpenTranInfo') IS NOT NULL DROP TABLE #OpenTranInfo;

CREATE TABLE #OpenTranInfo
(
    DatabaseName SYSNAME,
    SessionId INT,
    TransactionId BIGINT,
    TransactionName NVARCHAR(255),
    TransactionType NVARCHAR(60),
    TransactionState NVARCHAR(60),
    TransactionBeginTime DATETIME,
    LogUsedMB DECIMAL(18,2),
    EstimatedRowsAffected BIGINT,
    HostName NVARCHAR(255),
    LoginName NVARCHAR(255),
    ProgramName NVARCHAR(255),
    CurrentStatement NVARCHAR(MAX)
);

DECLARE @cmd NVARCHAR(MAX);
DECLARE @dbname SYSNAME;

DECLARE db_cursor CURSOR FOR
SELECT name FROM sys.databases WHERE database_id > 4 AND state_desc = 'ONLINE';

OPEN db_cursor;
FETCH NEXT FROM db_cursor INTO @dbname;

WHILE @@FETCH_STATUS = 0
BEGIN
    SET @cmd = N'
    USE [' + @dbname + N'];
    INSERT INTO #OpenTranInfo
    SELECT 
        DB_NAME() AS DatabaseName,
        es.session_id,
        at.transaction_id,
        at.name AS TransactionName,
        CASE at.transaction_type
            WHEN 1 THEN ''Read/Write''
            WHEN 2 THEN ''Read-Only''
            WHEN 3 THEN ''System''
            WHEN 4 THEN ''Distributed''
            ELSE ''Unknown''
        END AS TransactionType,
        CASE at.transaction_state
            WHEN 0 THEN ''Not Initialized''
            WHEN 1 THEN ''Active''
            WHEN 2 THEN ''Ended''
            WHEN 3 THEN ''Commit Started''
            WHEN 4 THEN ''Prepared''
            WHEN 5 THEN ''Committed''
            WHEN 6 THEN ''Rolling Back''
            WHEN 7 THEN ''Rolled Back''
            ELSE ''Unknown''
        END AS TransactionState,
        atdt.database_transaction_begin_time AS TransactionBeginTime,
        CAST(atdt.database_transaction_log_bytes_used / 1024.0 / 1024.0 AS DECIMAL(18,2)) AS LogUsedMB,
        ISNULL(er.row_count, 0) AS EstimatedRowsAffected,
        es.host_name,
        es.login_name,
        es.program_name,
        SUBSTRING(st.text, er.statement_start_offset / 2 + 1,
            (CASE WHEN er.statement_end_offset = -1 
                  THEN LEN(CONVERT(NVARCHAR(MAX), st.text)) * 2 
                  ELSE er.statement_end_offset END - er.statement_start_offset) / 2 + 1) AS CurrentStatement
    FROM sys.dm_tran_active_transactions AS at
    JOIN sys.dm_tran_database_transactions AS atdt
        ON at.transaction_id = atdt.transaction_id
    JOIN sys.dm_exec_sessions AS es
        ON es.session_id IN (
            SELECT session_id FROM sys.dm_tran_session_transactions WHERE transaction_id = at.transaction_id
        )
    LEFT JOIN sys.dm_exec_requests AS er
        ON es.session_id = er.session_id
    OUTER APPLY sys.dm_exec_sql_text(er.sql_handle) AS st
    WHERE atdt.database_transaction_state = 1; -- Active
    ';
    EXEC sp_executesql @cmd;
    FETCH NEXT FROM db_cursor INTO @dbname;
END;

CLOSE db_cursor;
DEALLOCATE db_cursor;

SELECT 
    DatabaseName,
    SessionId,
    TransactionName,
    TransactionType,
    TransactionState,
    TransactionBeginTime,
    LogUsedMB,
    EstimatedRowsAffected,
    HostName,
    LoginName,
    ProgramName,
    CurrentStatement
FROM #OpenTranInfo
ORDER BY LogUsedMB DESC, EstimatedRowsAffected DESC;

-------------------------------------------------------------------------
-- check blockng sessions
SELECT
    blocking_session_id AS BlockingSessionId,
    session_id          AS BlockedSessionId,
    DB_NAME(database_id) AS DatabaseName,
    wait_type,
    wait_time / 1000.0  AS WaitDurationSeconds,
    wait_resource,
    status,
    command,
    login_name,
    host_name,
    program_name
FROM sys.dm_exec_requests
WHERE blocking_session_id <> 0
ORDER BY blocking_session_id, session_id;
-------------------------------------------------------------------------


--Check AG latencies - On primary


/*

Log_Send_Queue_Size_KB: Quantidade de logs pendentes de envio para a réplica secundária.

Log_Send_Rate_KBps: Velocidade de envio dos logs (KB/s).

Redo_Queue_Size_KB: Tamanho da fila de redo pendente na réplica secundária.

Redo_Queue_Size_GB: Tamanho da fila de redo pendente na réplica secundária em GB.

Redo_Rate_KBps: Velocidade de processamento do redo (KB/s).

Estimated_Log_Send_Time_Seconds: Tempo estimado (em segundos) para concluir o envio dos logs.

Estimated_Redo_Time_Seconds: Tempo estimado (em segundos) para aplicar as transações na réplica secundária.

Caso a taxa de envio (Log_Send_Rate_KBps) ou a taxa de redo (Redo_Rate_KBps) seja zero, o tempo estimado aparecerá como NULL, pois o cálculo não pode ser realizado.

Estimated_Log_Send_Completion_Time: Horário estimado para a conclusão do envio dos logs.

Estimated_Redo_Completion_Time: Horário estimado para a conclusão do redo.

*/
 
SELECT 

    ag.name AS AG_Name,
    ar.replica_server_name AS Replica_Name,
    drs.database_id,
    db_name(drs.database_id) AS Database_Name,
    drs.log_send_queue_size AS Log_Send_Queue_Size_KB,  -- Tamanho da fila de envio de logs (KB)
    drs.log_send_rate AS Log_Send_Rate_KBps,            -- Taxa de envio de logs (KB/s)
    drs.redo_queue_size AS Redo_Queue_Size_KB,          -- Tamanho da fila de redo (KB)
    CAST(drs.redo_queue_size / 1048576.0 AS DECIMAL(10,4)) AS Redo_Queue_Size_GB,  -- Tamanho da fila de redo (GB)
    drs.redo_rate AS Redo_Rate_KBps,                    -- Taxa de processamento do redo (KB/s)
 
    -- Tempo estimado para envio e aplicação do redo

    CASE 
        WHEN drs.log_send_rate > 0 
        THEN CAST(drs.log_send_queue_size / drs.log_send_rate AS DECIMAL(10,2))
        ELSE NULL 
    END AS Estimated_Log_Send_Time_Seconds,            

    CASE 
        WHEN drs.redo_rate > 0 
        THEN CAST(drs.redo_queue_size / drs.redo_rate AS DECIMAL(10,2))
        ELSE NULL 
    END AS Estimated_Redo_Time_Seconds,                
 
    -- Horário estimado de conclusão do envio e do redo
    DATEADD(SECOND, 
        CASE 
            WHEN drs.log_send_rate > 0 
            THEN drs.log_send_queue_size / drs.log_send_rate 
            ELSE 0 
        END, GETDATE()) AS Estimated_Log_Send_Completion_Time,
    DATEADD(SECOND, 
        CASE 
            WHEN drs.redo_rate > 0 
            THEN drs.redo_queue_size / drs.redo_rate 
            ELSE 0 
        END, GETDATE()) AS Estimated_Redo_Completion_Time,    

    -- Percentual de conclusão do envio de logs
    CASE 
        WHEN (drs.log_send_queue_size + drs.log_send_rate) > 0 
        THEN CAST(100 * (1 - (CAST(drs.log_send_queue_size AS FLOAT) / 
            NULLIF(CAST(drs.log_send_queue_size + drs.log_send_rate AS FLOAT), 0))) AS DECIMAL(5,2))
        ELSE 100 
    END AS Log_Send_Completion_Percentage,
 
    -- Percentual de conclusão do redo
    CASE 
        WHEN (drs.redo_queue_size + drs.redo_rate) > 0 
        THEN CAST(100 * (1 - (CAST(drs.redo_queue_size AS FLOAT) / 
            NULLIF(CAST(drs.redo_queue_size + drs.redo_rate AS FLOAT), 0))) AS DECIMAL(5,2))
        ELSE 100 
    END AS Redo_Completion_Percentage
FROM sys.dm_hadr_database_replica_states drs
JOIN sys.availability_replicas ar 
    ON drs.replica_id = ar.replica_id
JOIN sys.availability_groups ag 
    ON ar.group_id = ag.group_id
WHERE drs.is_local = 0  -- Foca nos dados da réplica secundária
ORDER BY AG_Name, Database_Name;
 


----------------------------------------------------------------------------------------------





The availability group database "AGSetup" is changing roles from "SECONDARY" to "RESOLVING" because the mirroring session or availability group failed over due to role synchronization. 
This is an informational message only. No user action is required.

Always On Availability Groups connection with primary database established for secondary database 'ADM' on the availability replica 'ppolwcdes000fb\PRD' with Replica ID: {17ab4082-1e7b-4d97-8775-84a4c0e332b7}. 
This is an informational message only. No user action is required.

The availability group database "ADM" is changing roles from "PRIMARY" to "RESOLVING" because the mirroring session or availability group failed over due to role synchronization. This is an informational message only. No user action is required.


spid95s	Starting up database 'ADM'.
spid95s	Parallel redo is started for database 'ADM' with worker pool size [8].
spid95s	Recovery of database 'ADM' (8) is 0% complete (approximately 24189 seconds remain). Phase 2 of 3. This is an informational message only. No user action is required.
spid95s	Recovery of database 'ADM' (8) is 0% complete (approximately 4703 seconds remain). Phase 2 of 3. This is an informational message only. No user action is required.
spid95s	Recovery of database 'ADM' (8) is 0% complete (approximately 4690 seconds remain). Phase 2 of 3. This is an informational message only. No user action is required.
spid95s	Recovery of database 'ADM' (8) is 1% complete (approximately 4673 seconds remain). Phase 2 of 3. This is an informational message only. No user action is required.
spid95s	Recovery of database 'ADM' (8) is 1% complete (approximately 4654 seconds remain). Phase 2 of 3. This is an informational message only. No user action is required.
spid95s	Recovery of database 'ADM' (8) is 1% complete (approximately 4651 seconds remain). Phase 2 of 3. This is an informational message only. No user action is required.
spid95s	Always On Availability Groups connection with primary database established for secondary database 'ADM' on the availability replica 'ppolwcdes000fb\PRD' with Replica ID: {17ab4082-1e7b-4d97-8775-84a4c0e332b7}. This is an informational message only. No user action is required.
spid95s	Recovery completed for database ADM (database ID 8) in 84 second(s) (analysis 99 ms, redo 82561 ms, undo 0 ms [system undo 998265807728 ms, regular undo 1054537610234 ms].) This is an informational message only. No user action is required.
spid21s	Always On Availability Groups connection with primary database established for secondary database 'ADM' on the availability replica 'ppolwcdes000fb\PRD' with Replica ID: {17ab4082-1e7b-4d97-8775-84a4c0e332b7}. This is an informational message only. No user action is required.
spid95s	CHECKDB for database 'ADM' finished without errors on 2025-11-09 18:00:07.637 (local time). This is an informational message only; no user action is required.



SELECT
    s.session_id,
    s.login_name,
    s.host_name,
    s.program_name,
    s.status,
    s.open_transaction_count,
    r.command,
    r.status AS request_status,
    r.cpu_time,
    r.total_elapsed_time,
    r.reads,
    r.writes,
    DB_NAME(r.database_id) AS database_name,
    r.blocking_session_id,
    r.wait_type,
    r.wait_time,
    r.last_wait_type
FROM sys.dm_exec_sessions s
LEFT JOIN sys.dm_exec_requests r
    ON s.session_id = r.session_id
WHERE s.session_id = 95;
