--- Check database log space on primary
-- Ag latence can lock for reuse logspace

DBCC SQLPERF(LOGSPACE)

SELECT HOST_NAME() AS client_hostname;


USE Callidus;
GO

SELECT
    total_log_size_in_bytes / 1024.0 / 1024 / 1024 AS total_log_size_GB,
    used_log_space_in_bytes / 1024.0 / 1024 / 1024 AS used_log_space_GB,
    (total_log_size_in_bytes - used_log_space_in_bytes) / 1024.0 / 1024 / 1024 AS free_log_space_GB,
    (used_log_space_in_bytes * 1.0 / total_log_size_in_bytes) * 100 AS used_percent
FROM sys.dm_db_log_space_usage;

-- Check servr uptime 
-- Check server error log
-- Check physical disk idle time on perfmon

--Check on AG Dasborad for latency:
Usar as columnas sync performance sec 
Redo_Queue_Size_KB
Redo_Rate_KBps
Last commit time para ver de qual tempo passado são os logs enviados

--Para listar na maquina prymary o queue size o send rate e o estimated log_send_completion_time

/*
Log_Send_Queue_Size_KB: Quantidade de logs pendentes de envio para a réplica secundária.
Log_Send_Rate_KBps: Velocidade de envio dos logs (KB/s).
Redo_Queue_Size_KB: Tamanho da fila de redo pendente na réplica secundária.
Redo_Queue_Size_GB: Tamanho da fila de redo pendente na réplica secundária em GB.
Redo_Rate_KBps: Velocidade de processamento do redo (KB/s).
Estimated_Log_Send_Time_Seconds: Tempo estimado (em segundos) para concluir o envio dos logs.
Estimated_Redo_Time_Seconds: Tempo estimado (em segundos) para aplicar as transações na réplica secundária.
Caso a taxa de envio (Log_Send_Rate_KBps) ou a taxa de redo (Redo_Rate_KBps) seja zero, o tempo estimado aparecerá como NULL, pois o cálculo não pode ser realizado.
Estimated_Log_Send_Completion_Time: Horário estimado para a conclusão do envio dos logs.
Estimated_Redo_Completion_Time: Horário estimado para a conclusão do redo.
*/

SELECT 
    ag.name AS AG_Name,
    ar.replica_server_name AS Replica_Name,
    drs.database_id,
    db_name(drs.database_id) AS Database_Name,
    drs.log_send_queue_size AS Log_Send_Queue_Size_KB,  -- Tamanho da fila de envio de logs (KB)
    drs.log_send_rate AS Log_Send_Rate_KBps,            -- Taxa de envio de logs (KB/s)
    
    drs.redo_queue_size AS Redo_Queue_Size_KB,          -- Tamanho da fila de redo (KB)
    CAST(drs.redo_queue_size / 1048576.0 AS DECIMAL(10,4)) AS Redo_Queue_Size_GB,  -- Tamanho da fila de redo (GB)

    drs.redo_rate AS Redo_Rate_KBps,                    -- Taxa de processamento do redo (KB/s)

    -- Tempo estimado para envio e aplicação do redo
    CASE 
        WHEN drs.log_send_rate > 0 
        THEN CAST(drs.log_send_queue_size / drs.log_send_rate AS DECIMAL(10,2))
        ELSE NULL 
    END AS Estimated_Log_Send_Time_Seconds,            

    CASE 
        WHEN drs.redo_rate > 0 
        THEN CAST(drs.redo_queue_size / drs.redo_rate AS DECIMAL(10,2))
        ELSE NULL 
    END AS Estimated_Redo_Time_Seconds,                

    -- Horário estimado de conclusão do envio e do redo
    DATEADD(SECOND, 
        CASE 
            WHEN drs.log_send_rate > 0 
            THEN drs.log_send_queue_size / drs.log_send_rate 
            ELSE 0 
        END, GETDATE()) AS Estimated_Log_Send_Completion_Time,

    DATEADD(SECOND, 
        CASE 
            WHEN drs.redo_rate > 0 
            THEN drs.redo_queue_size / drs.redo_rate 
            ELSE 0 
        END, GETDATE()) AS Estimated_Redo_Completion_Time,    

    -- Percentual de conclusão do envio de logs
    CASE 
        WHEN (drs.log_send_queue_size + drs.log_send_rate) > 0 
        THEN CAST(100 * (1 - (CAST(drs.log_send_queue_size AS FLOAT) / 
            NULLIF(CAST(drs.log_send_queue_size + drs.log_send_rate AS FLOAT), 0))) AS DECIMAL(5,2))
        ELSE 100 
    END AS Log_Send_Completion_Percentage,

    -- Percentual de conclusão do redo
    CASE 
        WHEN (drs.redo_queue_size + drs.redo_rate) > 0 
        THEN CAST(100 * (1 - (CAST(drs.redo_queue_size AS FLOAT) / 
            NULLIF(CAST(drs.redo_queue_size + drs.redo_rate AS FLOAT), 0))) AS DECIMAL(5,2))
        ELSE 100 
    END AS Redo_Completion_Percentage

FROM sys.dm_hadr_database_replica_states drs
JOIN sys.availability_replicas ar 
    ON drs.replica_id = ar.replica_id
JOIN sys.availability_groups ag 
    ON ar.group_id = ag.group_id
WHERE drs.is_local = 0  -- Foca nos dados da réplica secundária
ORDER BY AG_Name, Database_Name;


--- query simples


SELECT 
    ag.name AS AG_Name,
    ar.replica_server_name AS Replica_Name,
    drs.database_id,
    db_name(drs.database_id) AS Database_Name,
    drs.log_send_queue_size AS Log_Send_Queue_Size_KB,  -- Tamanho da fila de envio de logs (KB)
    drs.log_send_rate AS Log_Send_Rate_KBps,           -- Taxa de envio de logs (KB/s)
    drs.redo_queue_size AS Redo_Queue_Size_KB,         -- Tamanho da fila de redo (KB)
    drs.redo_rate AS Redo_Rate_KBps,                   -- Taxa de processamento do redo (KB/s)
    CASE 
        WHEN drs.log_send_rate > 0 
        THEN CAST(drs.log_send_queue_size / drs.log_send_rate AS DECIMAL(10,2))
        ELSE NULL 
    END AS Estimated_Log_Send_Time_Seconds,            -- Tempo estimado para envio (s)
    CASE 
        WHEN drs.redo_rate > 0 
        THEN CAST(drs.redo_queue_size / drs.redo_rate AS DECIMAL(10,2))
        ELSE NULL 
    END AS Estimated_Redo_Time_Seconds                 -- Tempo estimado para aplicação do redo (s)
FROM sys.dm_hadr_database_replica_states drs
JOIN sys.availability_replicas ar 
    ON drs.replica_id = ar.replica_id
JOIN sys.availability_groups ag 
    ON ar.group_id = ag.group_id
WHERE drs.is_local = 0  -- Foca nos dados da réplica secundária
ORDER BY AG_Name, Database_Name;

------------------------------------------------------
-- Mais dados informativos do log send
-- Este rodar no secudario q está apicando os logs
SELECT 
    d.name AS database_name,
    drs.database_id,
    drs.redo_queue_sizeKB,
    drs.redo_rateKB,
    drs.last_redone_time,
    drs.last_commit_time,
    drs.is_suspended,
    drs.synchronization_state_desc,
    drs.synchronization_health_desc,
    drs.is_local,
    drs.is_commit_participant
FROM sys.dm_hadr_database_replica_states drs
JOIN sys.databases d ON drs.database_id = d.database_id
WHERE drs.is_local = 1
ORDER BY d.name;

------------------------------------
-- para listar os threads HADR para cada database no nó secundario q está recebendo os logs
--rodar no node secundário

-- para contar os hdr por database 
select db_name(database_id) as dbname, count(*)
from sys.dm_exec_requests
where 1=1
and command in('PARALLEL REDO HELP TASK', 'PARALLEL REDO TASK', 'DB STARTUP')
--and database_id= db_id('dbname')
group by  db_name(database_id)

---- Para liberar threads de bancos que nao estao precisando ou já estao sincronizados:
 1. Restart the Data Movement for the AG Replica
This is the safest and most targeted way to reset the threads used for synchronization:

-- On the secondary replica
ALTER DATABASE [YourDatabaseName] SET HADR SUSPEND;

-- Wait a few seconds, then resume
ALTER DATABASE [YourDatabaseName] SET HADR RESUME;

--ou
Use this supported and safe method to restart the AG threads:

-- On the secondary (to restart redo threads):
ALTER DATABASE [YourDatabaseName] SET HADR SUSPEND;
WAITFOR DELAY '00:00:05';
ALTER DATABASE [YourDatabaseName] SET HADR RESUME;
This is the best method to reset AG-related threads (including redo worker threads) without downtime.

---------------------------
-- Dica do bruno caso os HDRs nao tenham sido todos iniciados

Use Trace Flag 3459 for Diagnostics
You're already aware of this — TF 3459 doesn't fix but helps diagnose stuck redo by forcing logging for long redo operations.

-- Enables single-threaded redo
DBCC TRACEON (3459, -1);
GO

-- Checks if trace flag 3459 is active
DBCC TRACESTATUS(3459);
GO
-- Disables single-threaded redo, reverting to parallel redo
DBCC TRACEOFF (3459, -1);
GO

select DB_NAME(database_id), COUNT(*)
from sys.dm_exec_requests
  where command in ('PARAELLEL REDO HELP TASK','PARALLEL REDO TASK','DB STARTUP')
  GROUP BY DB_NAME(database_id)


------------------------------------------------------------------------------------------
--To check AG thread activity:

SELECT * 
FROM sys.dm_hadr_database_replica_states
WHERE is_local = 1;

-- when check for HDR redo apply performance goto the secondary database always
-- Monitor thread performance
If redo_rate is low and redo_queue_size is growing, the redo thread is not keeping up.

SELECT 
    DB_NAME(database_id) AS database_name,
    redo_queue_size,        -- KB of log waiting to be redone
    redo_rate,              -- KB/sec being applied
    last_commit_time,
    last_redone_time,
    synchronization_state_desc
FROM sys.dm_hadr_database_replica_states
WHERE is_local = 1;

-- Monitor REDO waits:

SELECT wait_type, waiting_tasks_count, wait_time_ms 
FROM sys.dm_os_wait_stats 
WHERE wait_type LIKE 'REDO%';

-- Check HADR Threads in Use
-- use on the secondary
SELECT 
    r.session_id,
    r.status,
    r.command,
    r.database_id,
    DB_NAME(r.database_id) AS database_name,
    r.scheduler_id,
    s.host_name,
    s.program_name,
    r.wait_type,
    r.wait_time,
    r.wait_resource,
    r.cpu_time,
    r.total_elapsed_time
FROM sys.dm_exec_requests r
JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
WHERE 
    (r.command LIKE '%HADR%' OR 
    r.command LIKE '%REDO%' OR 
    r.command LIKE '%DB STARTUP%')
	and DB_NAME(r.database_id)='TAD91' ;



----------------------------------------------------------------------------------------

-- para listar o I/O wait no nó secundario q está recebendo os logs
Notes
Values are cumulative since the last SQL Server service restart. For trends or time-based analysis, you must take two samples and compute the difference.
Does not distinguish between user and internal SQL Server operations.
Works for data files (.mdf/.ndf) and log files (.ldf).
Useful in both OLTP and OLAP environments for storage diagnostics.

SELECT 
    DB_NAME(vfs.database_id) AS DatabaseName,
    mf.name AS LogicalName,
    mf.physical_name,
    vfs.num_of_reads,
    vfs.num_of_writes,
    vfs.io_stall_read_ms,
    vfs.io_stall_write_ms,
    vfs.num_of_reads + vfs.num_of_writes AS TotalIO,
    (vfs.io_stall_read_ms + vfs.io_stall_write_ms) / 
        NULLIF(vfs.num_of_reads + vfs.num_of_writes, 0) AS AvgStallPerIO_ms
FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS vfs
JOIN sys.master_files AS mf 
    ON vfs.database_id = mf.database_id AND vfs.file_id = mf.file_id
	where DB_NAME(vfs.database_id) ='Callidus' 
ORDER BY AvgStallPerIO_ms DESC

--------------------------------------------------------------------------------------
-- I/O Response time per database and files
Explanation of New Columns:
Column	Meaning
ReadsInInterval	Total reads in 10s
ReadStall_ms	Time spent waiting on those reads
Avg_Read_Response_ms	Average read response time per read in ms
WritesInInterval	Total writes in 10s
WriteStall_ms	Time spent waiting on those writes
Avg_Write_Response_ms	Average write response time per write in ms
Interval_ms



-- Step 1: Capture start time
DECLARE @StartTime DATETIME2 = SYSDATETIME();

-- Step 2: Capture initial stats
IF OBJECT_ID('tempdb..#io_stats_1') IS NOT NULL DROP TABLE #io_stats_1;

SELECT 
    vs.database_id,
    vs.file_id,
    vs.num_of_reads,
    vs.io_stall_read_ms,
    vs.num_of_writes,
    vs.io_stall_write_ms
INTO #io_stats_1
FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS vs;

-- Step 3: Wait 10 seconds
WAITFOR DELAY '00:00:10';

-- Step 4: Capture end time
DECLARE @EndTime DATETIME2 = SYSDATETIME();
DECLARE @ElapsedTime_ms INT = DATEDIFF(MILLISECOND, @StartTime, @EndTime);

-- Step 5: Output elapsed time
SELECT 
    @StartTime AS StartTime,
    @EndTime AS EndTime,
    @ElapsedTime_ms AS ElapsedTime_ms;

-- Step 6: Capture and calculate deltas + response time
SELECT 
mf.database_id,
    DB_NAME(mf.database_id) AS [Database],
    mf.physical_name,
    
    vs2.num_of_reads - vs1.num_of_reads AS ReadsInInterval,
    vs2.io_stall_read_ms - vs1.io_stall_read_ms AS TimeSpentWaiting_ReadStall_ms,
    CASE 
        WHEN (vs2.num_of_reads - vs1.num_of_reads) > 0 THEN 
            CAST(vs2.io_stall_read_ms - vs1.io_stall_read_ms AS FLOAT) / 
            (vs2.num_of_reads - vs1.num_of_reads)
        ELSE NULL 
    END AS Read_ResponseTime_ms,
    
    vs2.num_of_writes - vs1.num_of_writes AS WritesInInterval,
    vs2.io_stall_write_ms - vs1.io_stall_write_ms AS TimeSpentWaiting_WriteStall_ms,
    CASE 
        WHEN (vs2.num_of_writes - vs1.num_of_writes) > 0 THEN 
            CAST(vs2.io_stall_write_ms - vs1.io_stall_write_ms AS FLOAT) / 
            (vs2.num_of_writes - vs1.num_of_writes)
        ELSE NULL 
    END AS Write_ResponseTime_ms,

    @ElapsedTime_ms AS Interval_ms

FROM sys.dm_io_virtual_file_stats(NULL, NULL) AS vs2
JOIN #io_stats_1 vs1
    ON vs1.database_id = vs2.database_id AND vs1.file_id = vs2.file_id
JOIN sys.master_files mf
    ON mf.database_id = vs2.database_id AND mf.file_id = vs2.file_id
WHERE DB_NAME(mf.database_id)='Callidus' AND (
   (vs2.num_of_reads - vs1.num_of_reads) > 0 
   OR (vs2.num_of_writes - vs1.num_of_writes) > 0)
   
ORDER BY DB_NAME(mf.database_id), Read_ResponseTime_ms DESC, Write_ResponseTime_ms DESC;
