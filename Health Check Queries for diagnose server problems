--Verificar o uso de logs para todos os databases

DBCC SQLPERF(LOGSPACE)


--- List Hardware CPU count, memory and sql server start time

SELECT
    cpu_count AS [Logical CPUs],
    hyperthread_ratio AS [Hyperthread Ratio],
    physical_memory_kb / 1024 AS [Physical Memory (MB)],
    sqlserver_start_time AS [SQL Server Start Time],
    scheduler_count AS [Schedulers],
    socket_count AS [CPU Sockets],
    cores_per_socket AS [Cores per Socket],
    numa_node_count AS [NUMA Nodes]
FROM
    sys.dm_os_sys_info;


--[CPU from Queries as Percent of Total CPU Capacity]

DECLARE @init_sum_cpu_time int,
        @utilizedCpuCount int 
--get CPU count used by SQL Server
SELECT @utilizedCpuCount = COUNT( * )
FROM sys.dm_os_schedulers
WHERE status = 'VISIBLE ONLINE' 
--calculate the CPU usage by queries OVER a 5 sec interval 
SELECT @init_sum_cpu_time = SUM(cpu_time) FROM sys.dm_exec_requests
WAITFOR DELAY '00:00:05'
SELECT CONVERT(DECIMAL(5,2), ((SUM(cpu_time) - @init_sum_cpu_time) / (@utilizedCpuCount * 5000.00)) * 100) AS [CPU from Queries as Percent of Total CPU Capacity] 
FROM sys.dm_exec_requests
go


-- List long running queries and current wait class
-- Exclude internal processes
SELECT
    r.session_id,
s.login_name,
    r.status,
    r.command,
    r.cpu_time / 1000.0 AS cpu_time_sec,
    r.total_elapsed_time / 1000.0 AS elapsed_time_sec,
    r.wait_type,
    r.wait_time / 1000.0 AS wait_time_sec,
    r.blocking_session_id,
    DB_NAME(r.database_id) AS database_name,
    SUBSTRING(t.text, (r.statement_start_offset / 2) + 1,
              CASE 
                  WHEN r.statement_end_offset = -1 THEN LEN(CONVERT(NVARCHAR(MAX), t.text)) 
                  ELSE (r.statement_end_offset - r.statement_start_offset) / 2 + 1 
              END) AS query_text
FROM sys.dm_exec_requests AS r
INNER JOIN sys.dm_exec_sessions AS s
    ON r.session_id = s.session_id
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) AS t
WHERE r.session_id <> @@SPID
AND s.is_user_process = 1 -- Excludes internal/system sessions
AND r.total_elapsed_time > 5000 -- Only queries running longer than 5 seconds
ORDER BY r.total_elapsed_time DESC;



-- Lista por ordem de CPU Cumulativo e mostra os logins e hostnames

SELECT TOP 10 s.session_id,
	s.login_name,
           r.status,
           r.cpu_time / 1000.0 AS cpu_time_sec,
           r.logical_reads,
           r.reads,
           r.writes,
           r.total_elapsed_time / (1000 * 60) 'Elaps M',
           SUBSTRING(st.TEXT, (r.statement_start_offset / 2) + 1,
           ((CASE r.statement_end_offset
                WHEN -1 THEN DATALENGTH(st.TEXT)
                ELSE r.statement_end_offset
            END - r.statement_start_offset) / 2) + 1) AS statement_text,
           COALESCE(QUOTENAME(DB_NAME(st.dbid)) + N'.' + QUOTENAME(OBJECT_SCHEMA_NAME(st.objectid, st.dbid)) 
           + N'.' + QUOTENAME(OBJECT_NAME(st.objectid, st.dbid)), '') AS command_text,
           r.command,
           s.host_name,
           s.program_name,
           s.last_request_end_time,
           s.login_time,
           r.open_transaction_count
FROM sys.dm_exec_sessions AS s
JOIN sys.dm_exec_requests AS r ON r.session_id = s.session_id CROSS APPLY sys.Dm_exec_sql_text(r.sql_handle) AS st
WHERE r.session_id != @@SPID
ORDER BY r.cpu_time DESC

--listar sessoes e queries por tempo de wait (nao cumulativo)


SELECT      r.session_ID [SPID],
            s.login_name,
            r.start_time [Start Time],
			r.Status,
            wait_time [Wait seconds],
            wait_type,
            DB_NAME(r.database_id) [Database],
            SUBSTRING(t.text,(r.statement_start_offset/2)+1,
            CASE WHEN statement_end_offset=-1 OR statement_end_offset=0
                 THEN (DATALENGTH(t.Text)-r.statement_start_offset/2)+1
                 ELSE (r.statement_end_offset-r.statement_start_offset)/2+1
            END) [Executing SQL],
            command,
            wait_resource,
            last_wait_type
FROM        sys.dm_exec_requests r
JOIN        sys.dm_exec_sessions s
      ON    r.session_id = s.session_id
OUTER APPLY sys.dm_exec_sql_text(sql_handle) t
WHERE       r.session_id != @@SPID -- don't show this query 
  AND       DB_NAME(r.database_id) != 'master'
ORDER BY    wait_time / 1000, r.start_time;

-- From CHATGPT Alternative: View the blocking tree (all sessions)
SELECT
    r.session_id,
    r.blocking_session_id,
    s.login_name,
    s.host_name,
    r.status,
    r.wait_type,
    r.wait_time,
    t.text AS [SQL Text]
FROM sys.dm_exec_requests r
JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
CROSS APPLY sys.dm_exec_sql_text(r.sql_handle) t
WHERE r.blocking_session_id <> 0;

-- List what query is running on a session

SELECT      r.start_time [Start Time],session_ID [SPID],
            DB_NAME(database_id) [Database],
            SUBSTRING(t.text,(r.statement_start_offset/2)+1,
            CASE WHEN statement_end_offset=-1 OR statement_end_offset=0
            THEN (DATALENGTH(t.Text)-r.statement_start_offset/2)+1
            ELSE (r.statement_end_offset-r.statement_start_offset)/2+1
            END) [Executing SQL],
            Status,command,wait_type,wait_time,wait_resource,
            last_wait_type
FROM        sys.dm_exec_requests r
OUTER APPLY sys.dm_exec_sql_text(sql_handle) t
WHERE       session_id != @@SPID -- don't show this query
AND         session_id = 31 -- don't show system queries
ORDER BY    r.start_time

-- Current session waits

SELECT
    r.session_id AS [SPID],
    s.login_name,
    r.status,
    r.command,
    r.wait_type,
    r.wait_time AS [Wait Time (ms)],
    r.last_wait_type,
    r.wait_resource,
    r.blocking_session_id,
    DB_NAME(r.database_id) AS [Database],
    SUBSTRING(t.text, (r.statement_start_offset / 2) + 1,
        CASE
            WHEN r.statement_end_offset = -1 OR r.statement_end_offset = 0
            THEN (DATALENGTH(t.text) - r.statement_start_offset / 2) + 1
            ELSE (r.statement_end_offset - r.statement_start_offset) / 2 + 1
        END
    ) AS [Executing SQL]
FROM
    sys.dm_exec_requests r
JOIN
    sys.dm_exec_sessions s ON r.session_id = s.session_id
OUTER APPLY
    sys.dm_exec_sql_text(r.sql_handle) t
WHERE
    r.session_id != @@SPID
    AND r.wait_type IS NOT NULL
ORDER BY
    r.wait_time DESC;

-- Current top 20 waits minus background processes
SELECT TOP 20
    r.session_id AS [SPID],
    s.login_name,
    r.status,
    r.command,
    r.wait_type,
    r.wait_time AS [Wait Time (ms)],
    r.last_wait_type,
    r.wait_resource,
    r.blocking_session_id,
    DB_NAME(r.database_id) AS [Database],
    SUBSTRING(t.text, (r.statement_start_offset / 2) + 1,
        CASE
            WHEN r.statement_end_offset = -1 OR r.statement_end_offset = 0
            THEN (DATALENGTH(t.text) - r.statement_start_offset / 2) + 1
            ELSE (r.statement_end_offset - r.statement_start_offset) / 2 + 1
        END
    ) AS [Executing SQL]
FROM
    sys.dm_exec_requests r
JOIN
    sys.dm_exec_sessions s ON r.session_id = s.session_id
OUTER APPLY
    sys.dm_exec_sql_text(r.sql_handle) t
WHERE
    r.session_id != @@SPID
    AND r.session_id > 50 -- Exclui processos de sistema
    AND r.wait_type IS NOT NULL
	and r.status !='background'
ORDER BY
    r.wait_time DESC;

-- Currents external waits OLEDB/linked servers
SELECT
    r.session_id,
    s.login_name,
    r.status,
    r.command,
    r.wait_type,
    r.wait_time AS [Wait Time (ms)],
    r.last_wait_type,
    r.wait_resource,
    r.blocking_session_id,
    DB_NAME(r.database_id) AS [Database],
    SUBSTRING(t.text, (r.statement_start_offset / 2) + 1,
        CASE
            WHEN r.statement_end_offset = -1 OR r.statement_end_offset = 0
            THEN (DATALENGTH(t.text) - r.statement_start_offset / 2) + 1
            ELSE (r.statement_end_offset - r.statement_start_offset) / 2 + 1
        END
    ) AS [Executing SQL]
FROM
    sys.dm_exec_requests r
JOIN
    sys.dm_exec_sessions s ON r.session_id = s.session_id
OUTER APPLY
    sys.dm_exec_sql_text(r.sql_handle) t
WHERE
    r.wait_type IN ('OLEDB', 'EXTERNAL_SCRIPT_NETWORK_IO', 'REMOTE_DB', 'MSDTC_RECEIVE', 'MSDTC_SEND')
    AND r.session_id > 50
ORDER BY
    r.wait_time DESC;




